## 模擬退火演算法:

### 能量相等於爬山演算法中的高度，差別在於是使用一個隨機機率決定變差時是否要過去
### 採用以溫度調控的機率特性，讓爬山演算法有機會跳脫較差的區域，因而找到更好的解。
### 跳出局部最優解，尋找到全局最優解或接近全局最優解。這是因為它允許在一定機率下接受較差的解，特別是在高溫階段，而隨著溫度降低，這種機率也逐漸減小，從而逐步收斂到一個較優的解。
![5](https://hackmd.io/_uploads/BJinoylC6.png)


## 基因演算法:
```
傳演算法具有保存良好基因的特性，並且藉由下列公式不斷改進。這個公式就是交配 (Crossover) 機制所造成的效果。

> 良好基因 (父) + 良好基因 (母) = 更好的個體

```

## 使用隨機來列舉:
![7](https://hackmd.io/_uploads/rkM-kxxR6.png)


## 使用隨機進行排列:
![8](https://hackmd.io/_uploads/rJVvyeg0p.png)




## 深度優先搜尋(DFS)演算法的工作原理如下：
```
1.首先將圖的任一個頂點放在堆疊的頂端。
2.取出堆疊頂部的項目並將其新增至存取清單。
3.建立該頂點的相鄰節點的清單。將不在存取清單中的新增至堆疊頂部。
4.不斷重複步驟2和3，直到堆疊為空。

```

## Ans: 
### 先使用具有 5 個頂點的無向圖
![1](https://hackmd.io/_uploads/BJ6QFdMF6.png)

### 從頂點 0 開始，DFS 演算法首先將其放入 Visited 清單中，並將其所有相鄰頂點放入堆疊中。
![2](https://hackmd.io/_uploads/ryvKKuGKT.png)

### 接下來，訪問堆疊頂部的元素（即 1）並訪問其相鄰節點，由於 0 已經被訪問過，所以我們訪問 2。
![3](https://hackmd.io/_uploads/r1xxJq_MKT.png)


### 頂點 2 在 4 中有一個未訪問的相鄰頂點，因此我們將其添加到堆疊頂部並訪問它。
![4](https://hackmd.io/_uploads/S1HGqdfYT.png)
![5](https://hackmd.io/_uploads/BJOG9_Gtp.png)

### 當我們訪問完最後一個元素3之後，它就沒有任何未訪問過的相鄰節點了，所以我們就完成了圖的深度優先遍歷。
![6](https://hackmd.io/_uploads/HJbBcdMKT.png)



## 廣度優先搜尋(BFS)運作方式:從根開始，先訪問某一層的所有節點，然後遍歷下一層的節點，直到訪問完所有節點，為此，使用隊列。目前層級的所有相鄰未存取節點都被推入佇列，當前層級的節點被標記為已存取並從佇列中彈出

## Ans:
### 最初佇列和存取陣列都是空的
![7](https://hackmd.io/_uploads/Sy-oOa7Yp.png)

### 將節點0推入佇列並標記為已存取
![8](https://hackmd.io/_uploads/HJDTd6XYa.png)

### 將節點0從佇列的前面移除，並存取未造訪的鄰居並將它們推入佇列。
![9](https://hackmd.io/_uploads/BkKyYaQKa.png)

### 將節點1從佇列的前面移除，並存取未造訪的鄰居並將它們推入佇列
![10](https://hackmd.io/_uploads/rJDftpXKa.png)

### 將節點2從佇列的前面移除，並存取未造訪的鄰居並將它們推入佇列
![11](https://hackmd.io/_uploads/By1StamKp.png)

### 將節點3從佇列的前面移除，並存取未造訪的鄰居並將它們推入佇列，我們可以看到節點 3 的每個鄰居都被訪問，因此移動到佇列前面的下一個節點。
![12](https://hackmd.io/_uploads/H1qdKpXKp.png)

### 將節點4從佇列的前面移除，並存取未造訪的鄰居並將它們推入佇列，我們可以看到節點 4 的每個鄰居都被訪問，因此移動到佇列前面的下一個節點。
![13](https://hackmd.io/_uploads/rJXstpQYT.png)

### 最後，Queue 變空了，所以，終止這些迭代過程。


## 佇列有一個特性就是先進先出(First In First Out, FIFO)，意思就是在一個串列中，先讀取的資料先輸出。



## A*搜尋演算法:


## 原理:
```
f(n)=g(n)+h(n)

f(n)為起點到終點的距離

g(n)為起點到任意頂點(目前位置)的實際距離

h(n)為任意頂點到目標頂點(終點)的估算距離

f(start) = 0 + h(start)

h(n) = |goal.x - n.x| + |goal.y - n.y| # 曼哈頓距離
```
### 曼哈頓距離:只能以直或橫線的方式來移動
### 適用於遊戲中的尋徑

